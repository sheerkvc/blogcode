---
title: 大小端存储和边界对齐の真题
date: 10/16/2022 16:31
tags: [边界对齐, 学习, 计组原理]
categories: 
  - 学习
  - 计组原理
---

**知识点：**
**1、结构体占字节数**
**2、小端地址与大段地址**
**3、 边界对齐方式存储**

------

> **【2012年计算机联考真题】**
> 某计算机存储器按字节编址，采用小端方式存放数据，假定编译器规定int和short型长度分别为32位和16位，并且数据按边界对齐存储，其C语言程序段如下：
>
> ```c
> struct{
> 	int a;
> 	char b;
> 	short c;
> }record;
> record.a=273;
> ```
>
> 若record变量的首地址为0xC008，则地址0xC008中的内容及record.c的地址分别为（ ）
>
> A . 0x00 0xC00D
>
> B . 0x00 0xC00E
>
> C . 0x11 0xC00D
>
> D . 0x11 0xC00E
>
> **【答案】 D**

分析：
**【1】存储器按字节编制。**
record------结构体变量-----占所有字节数之和。

| 类型    | 字节数  |
| ------- | ------- |
| int a   | 4       |
| char b  | 1       |
| short c | 2       |
| record  | 4+2+1=7 |

本来record应该是占得7个字节，如果这一题没有其他限制的话。
但是这一题出现了**数据按边界对齐存储**的条件，事实上，record占得是8个字节（需要后续分析才知道）。

| 结构体变量 | 字节数 |
| ---------- | ------ |
| record     | 8      |

 **【2】小端方式和大端方式**
> 1、大端方式：数据高字节—>内存的低地址；数据低字节---->内存的高地址。
> 1、小端方式：数据高字节—>内存的高地址；数据低字节---->内存的低地址。

如果广义成一个二进制对象，大端法对应的就是从头到尾存储，小端法就是从尾到头。

![2020060717515039](https://picgo172.oss-cn-qingdao.aliyuncs.com/img/2020060717515039.png)

**【3】数据按边界对齐存储**
**通俗的来说，变量的起始地址为其大小的整数倍，比如short占2个字节，起始地址从偶数地址开始。**
比较官方的定义为：即对于存放某长度为 m 字节的数据，**存放首地址需为m 字节的整数倍，同时，结构体整体的大小是最大成员长度的整数倍。**

![20200607175454866](https://picgo172.oss-cn-qingdao.aliyuncs.com/img/20200607175454866.png)

如上图所示，在采用边界对齐的情况下，当处理器需要访问a_变量和b_变量时都只需进行一次存取（图中花括号表示一次存取操作）。若不采用边界对齐，a_变量只要一次处理器操作，而b_变量却至少要进行两次操作。对于b_，处理器还得调用更多指令将其合成一个完整的 4 字节，这样无疑大大降低了程序效率。

------

**【解题步骤】**
1、273=0x111=0x 00 00 01 11（化成32位）
2、内存中的存储

| 地址   | 数据(0x)      |
| ------ | ------------- |
| 0xC008 | 11 (record.a) |
| 0xC009 | 01 (record.a) |
| 0xC00A | 00 (record.a) |
| 0xC00B | 00 (record.a) |
| 0xC00C | record.b      |
| 0xC00D | -----         |
| 0xC00E | record.c      |
| 0xC00F | record.c      |

**为什么0XC00D不能直接存放record.c？**
这就是前面所说的数据按照边界对齐方式存储的规则，**0XC00D，D化成十进制为13，不能整除2字节（record.c），因此后放。**

------







